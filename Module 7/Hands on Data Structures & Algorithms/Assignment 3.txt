import java.util.*;
import java.util.concurrent.*;

// ========== MERGE SORT ==========
class MergeSort {
    /**
     * Merge Sort implementation
     * Time Complexity: O(n log n) in all cases
     * Space Complexity: O(n)
     */
    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) return;
        
        int mid = arr.length / 2;
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        
        mergeSort(left);
        mergeSort(right);
        merge(arr, left, right);
    }
    
    private static void merge(int[] arr, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
            }
        }
        
        while (i < left.length) {
            arr[k++] = left[i++];
        }
        
        while (j < right.length) {
            arr[k++] = right[j++];
        }
    }
}

// ========== QUICK SORT ==========
class QuickSort {
    /**
     * Quick Sort implementation
     * Time Complexity: O(n log n) average, O(nÂ²) worst case
     * Space Complexity: O(log n) average
     */
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// ========== HEAP SORT ==========
class HeapSort {
    /**
     * Heap Sort implementation
     * Time Complexity: O(n log n) in all cases
     * Space Complexity: O(1)
     */
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// ========== BINARY SEARCH ==========
class BinarySearch {
    /**
     * Binary Search implementation
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // Target not found
    }
    
    // Edge cases demonstration
    public static void testEdgeCases() {
        System.out.println("\n=== Binary Search Edge Cases ===");
        
        // Empty array
        int[] empty = {};
        System.out.println("Empty array: " + binarySearch(empty, 5));
        
        // Single element
        int[] single = {5};
        System.out.println("Single element found: " + binarySearch(single, 5));
        System.out.println("Single element not found: " + binarySearch(single, 3));
        
        // All same elements
        int[] same = {2, 2, 2, 2, 2};
        System.out.println("All same elements: " + binarySearch(same, 2));
        
        // Target at boundaries
        int[] boundaries = {1, 3, 5, 7, 9};
        System.out.println("First element: " + binarySearch(boundaries, 1));
        System.out.println("Last element: " + binarySearch(boundaries, 9));
        
        // Target not in array
        System.out.println("Not in array: " + binarySearch(boundaries, 4));
    }
}

// ========== HASH TABLE ==========
class HashTable {
    /**
     * Basic Hash Table implementation with chaining
     */
    private LinkedList<Entry>[] table;
    private int size;
    private int capacity;
    
    private static class Entry {
        String key;
        Object value;
        
        Entry(String key, Object value) {
            this.key = key;
            this.value = value;
        }
    }
    
    @SuppressWarnings("unchecked")
    public HashTable(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.table = new LinkedList[capacity];
        for (int i = 0; i < capacity; i++) {
            table[i] = new LinkedList<>();
        }
    }
    
    public HashTable() {
        this(10); // Default capacity
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    public void insert(String key, Object value) {
        int index = hash(key);
        LinkedList<Entry> bucket = table[index];
        
        // Check if key already exists
        for (Entry entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value; // Update existing key
                return;
            }
        }
        
        // Add new key-value pair
        bucket.add(new Entry(key, value));
        size++;
    }
    
    public Object retrieve(String key) {
        int index = hash(key);
        LinkedList<Entry> bucket = table[index];
        
        for (Entry entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }
        
        return null; // Key not found
    }
    
    public boolean delete(String key) {
        int index = hash(key);
        LinkedList<Entry> bucket = table[index];
        
        Iterator<Entry> iterator = bucket.iterator();
        while (iterator.hasNext()) {
            Entry entry = iterator.next();
            if (entry.key.equals(key)) {
                iterator.remove();
                size--;
                return true;
            }
        }
        
        return false; // Key not found
    }
    
    public void display() {
        System.out.println("\n=== Hash Table Contents ===");
        for (int i = 0; i < capacity; i++) {
            System.out.print("Bucket " + i + ": ");
            for (Entry entry : table[i]) {
                System.out.print("[" + entry.key + "=" + entry.value + "] ");
            }
            System.out.println();
        }
    }
    
    public int getSize() {
        return size;
    }
}

// ========== GRAPH REPRESENTATION ==========
class GraphMatrix {
    /**
     * Graph representation using adjacency matrix
     */
    private int vertices;
    private int[][] matrix;
    
    public GraphMatrix(int vertices) {
        this.vertices = vertices;
        this.matrix = new int[vertices][vertices];
    }
    
    public void addEdge(int u, int v) {
        addEdge(u, v, 1);
    }
    
    public void addEdge(int u, int v, int weight) {
        if (u >= 0 && u < vertices && v >= 0 && v < vertices) {
            matrix[u][v] = weight;
            matrix[v][u] = weight; // For undirected graph
        }
    }
    
    public void display() {
        System.out.println("\n=== Adjacency Matrix ===");
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
}

class GraphList {
    /**
     * Graph representation using adjacency list
     */
    private Map<Integer, List<Edge>> adjList;
    
    private static class Edge {
        int destination;
        int weight;
        
        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }
    }
    
    public GraphList() {
        this.adjList = new HashMap<>();
    }
    
    public void addVertex(int vertex) {
        adjList.putIfAbsent(vertex, new ArrayList<>());
    }
    
    public void addEdge(int u, int v) {
        addEdge(u, v, 1);
    }
    
    public void addEdge(int u, int v, int weight) {
        adjList.putIfAbsent(u, new ArrayList<>());
        adjList.putIfAbsent(v, new ArrayList<>());
        
        adjList.get(u).add(new Edge(v, weight));
        adjList.get(v).add(new Edge(u, weight)); // For undirected graph
    }
    
    public void display() {
        System.out.println("\n=== Adjacency List ===");
        for (Map.Entry<Integer, List<Edge>> entry : adjList.entrySet()) {
            System.out.print(entry.getKey() + ": ");
            for (Edge edge : entry.getValue()) {
                System.out.print("-> " + edge.destination + "(" + edge.weight + ") ");
            }
            System.out.println();
        }
    }
}

// ========== PERFORMANCE ANALYSIS ==========
public class AlgorithmAnalysis {
    
    public static void main(String[] args) {
        System.out.println("=== ALGORITHM IMPLEMENTATION AND ANALYSIS ===\n");
        
        // Test sorting algorithms
        testSortingAlgorithms();
        
        // Test binary search with edge cases
        BinarySearch.testEdgeCases();
        
        // Test hash table
        testHashTable();
        
        // Test graph representations
        testGraphs();
        
        // Performance comparison
        comparePerformance();
    }
    
    public static void testSortingAlgorithms() {
        System.out.println("=== SORTING ALGORITHMS ===");
        
        int[] testArray = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Original array: " + Arrays.toString(testArray));
        
        // Merge Sort
        int[] mergeArray = testArray.clone();
        MergeSort.mergeSort(mergeArray);
        System.out.println("Merge Sort: " + Arrays.toString(mergeArray));
        
        // Quick Sort
        int[] quickArray = testArray.clone();
        QuickSort.quickSort(quickArray);
        System.out.println("Quick Sort: " + Arrays.toString(quickArray));
        
        // Heap Sort
        int[] heapArray = testArray.clone();
        HeapSort.heapSort(heapArray);
        System.out.println("Heap Sort: " + Arrays.toString(heapArray));
    }
    
    public static void testHashTable() {
        HashTable ht = new HashTable(5);
        
        // Insert sample data
        ht.insert("John", 25);
        ht.insert("Alice", 30);
        ht.insert("Bob", 35);
        ht.insert("Diana", 28);
        ht.insert("John", 26); // Update existing
        
        ht.display();
        
        // Retrieve operations
        System.out.println("\nJohn's age: " + ht.retrieve("John"));
        System.out.println("Alice's age: " + ht.retrieve("Alice"));
        System.out.println("Unknown: " + ht.retrieve("Unknown"));
        
        // Delete operation
        ht.delete("Bob");
        System.out.println("\nAfter deleting Bob:");
        ht.display();
    }
    
    public static void testGraphs() {
        // Adjacency Matrix
        GraphMatrix matrixGraph = new GraphMatrix(4);
        matrixGraph.addEdge(0, 1);
        matrixGraph.addEdge(0, 2);
        matrixGraph.addEdge(1, 2);
        matrixGraph.addEdge(2, 3);
        matrixGraph.display();
        
        // Adjacency List
        GraphList listGraph = new GraphList();
        listGraph.addEdge(0, 1, 2);
        listGraph.addEdge(0, 2, 3);
        listGraph.addEdge(1, 2, 1);
        listGraph.addEdge(2, 3, 4);
        listGraph.display();
    }
    
    public static void comparePerformance() {
        System.out.println("\n=== PERFORMANCE COMPARISON ===");
        
        int[] smallArray = generateRandomArray(1000);
        int[] mediumArray = generateRandomArray(10000);
        int[] largeArray = generateRandomArray(50000);
        
        // Test on random arrays
        System.out.println("Random Arrays:");
        testSortingPerformance(smallArray, "Small (1K)");
        testSortingPerformance(mediumArray, "Medium (10K)");
        testSortingPerformance(largeArray, "Large (50K)");
        
        // Test on sorted arrays
        System.out.println("\nSorted Arrays:");
        Arrays.sort(smallArray);
        Arrays.sort(mediumArray);
        Arrays.sort(largeArray);
        
        testSortingPerformance(smallArray, "Small (1K)");
        testSortingPerformance(mediumArray, "Medium (10K)");
        testSortingPerformance(largeArray, "Large (50K)");
    }
    
    public static int[] generateRandomArray(int size) {
        Random random = new Random();
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(size * 10);
        }
        return arr;
    }
    
    public static void testSortingPerformance(int[] arr, String label) {
        System.out.println("\n" + label + " Array:");
        
        // Merge Sort
        int[] mergeArr = arr.clone();
        long startTime = System.nanoTime();
        MergeSort.mergeSort(mergeArr);
        long mergeTime = System.nanoTime() - startTime;
        System.out.printf("Merge Sort: %,d ns%n", mergeTime);
        
        // Quick Sort
        int[] quickArr = arr.clone();
        startTime = System.nanoTime();
        QuickSort.quickSort(quickArr);
        long quickTime = System.nanoTime() - startTime;
        System.out.printf("Quick Sort: %,d ns%n", quickTime);
        
        // Heap Sort
        int[] heapArr = arr.clone();
        startTime = System.nanoTime();
        HeapSort.heapSort(heapArr);
        long heapTime = System.nanoTime() - startTime;
        System.out.printf("Heap Sort: %,d ns%n", heapTime);
        
        // Verify sorting is correct
        verifySorted(mergeArr, "Merge Sort");
        verifySorted(quickArr, "Quick Sort");
        verifySorted(heapArr, "Heap Sort");
    }
    
    public static void verifySorted(int[] arr, String algorithm) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                System.out.println("ERROR: " + algorithm + " failed to sort correctly!");
                return;
            }
        }
    }
}